{"version":3,"sources":["../../src/Find.js"],"names":["PouchDB","plugin","find","Find","docs","options","db","props","selector","limit","skip","sort","createIndex","index","fields","map","field","setStateIfMounted","cancel","changesCache","live","include_docs","since","return_docs","deleted","doc","state","findIndex","_id","found","splice","length","replacementDoc","push","sortOrders","prop","a","b","order","result","sortedIndex","lastDoc","firstDoc","otherProps","BaseComponent","propTypes","number","object","isRequired","array"],"mappings":"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","sourcesContent":["import PouchDB from 'pouchdb';\nimport find from 'pouchdb-find';\nimport { collate } from 'pouchdb-collate';\nimport { matchesSelector } from 'pouchdb-selector-core';\nimport { forbidExtraProps } from 'airbnb-prop-types';\nimport { number, object, array } from 'prop-types';\nimport BaseComponent from './BaseComponent';\nimport changesCache from './changesCache';\nimport renderProps from './renderProps';\nimport withDB from './withDB';\n\nPouchDB.plugin(find);\n\nclass Find extends BaseComponent {\n  static propTypes = forbidExtraProps({\n    ...BaseComponent.propTypes,\n    limit: number,\n    selector: object.isRequired,\n    skip: number,\n    sort: array\n  });\n  state = {\n    docs: []\n  };\n  async listen(options) {\n    const { props: { db } } = this;\n    const { selector, limit, skip, sort } = options;\n    if (selector) {\n      if (sort) {\n        await db.createIndex({\n          index: {\n            fields: sort.map(\n              field =>\n                typeof field === 'object' ? Object.keys(field)[0] : field\n            )\n          }\n        });\n      }\n      const { docs } = await db.find(options);\n      if (this.setStateIfMounted({ docs })) {\n        // To find deleted and other non-matching documents, listen all changes\n        // and use selector in 'change' event.\n        this.cancel = db::changesCache(\n          {\n            live: true,\n            include_docs: true,\n            since: 'now',\n            // Documents are kept in memory. 'complete' event can return an\n            // empty array.\n            return_docs: false\n          },\n          async ({ deleted, doc }) => {\n            const docs = [...this.state.docs];\n            const index = docs.findIndex(({ _id }) => doc._id === _id);\n            const found = index !== -1;\n            // Document was deleted or it does not match the selector?\n            if (deleted || (selector && !matchesSelector(doc, selector))) {\n              if (found) {\n                // Remove.\n                docs.splice(index, 1);\n                const { length } = docs;\n                // At the limit?\n                if (length + 1 === limit) {\n                  const { docs: [replacementDoc] } = await db.find({\n                    ...options,\n                    limit: 1,\n                    skip: (options.skip || 0) + length\n                  });\n                  if (replacementDoc) {\n                    docs.push(replacementDoc);\n                  }\n                }\n                this.setStateIfMounted({\n                  docs\n                });\n              }\n            } else {\n              if (found) {\n                // Update.\n                docs[index] = doc;\n              } else {\n                // Create.\n                docs.push(doc);\n              }\n              if (sort) {\n                const sortOrders = sort.map(\n                  prop =>\n                    typeof prop === 'object'\n                      ? Object.entries(prop)[0]\n                      : // Default sort order is 'asc'\n                        [prop, 'asc']\n                );\n                docs.sort((a, b) => {\n                  for (const [prop, order] of sortOrders) {\n                    const result = collate(a[prop], b[prop]);\n                    if (result !== 0) {\n                      return order === 'asc' ? result : -result;\n                    }\n                  }\n                  return 0;\n                });\n              }\n              const sortedIndex = docs.findIndex(({ _id }) => doc._id === _id);\n              // Document update, new place supposed to be last, `limit` option\n              // is set and limit was reached?\n              if (found && sortedIndex + 1 === limit) {\n                // Get the actual last document.\n                const { docs: [lastDoc] } = await db.find({\n                  ...options,\n                  limit: 1,\n                  skip: (options.skip || 0) + sortedIndex\n                });\n                if (lastDoc?._id !== doc._id) {\n                  docs[sortedIndex] = lastDoc;\n                }\n              }\n              // `skip` option is set and document supposed to be first?\n              if (skip && sortedIndex === 0) {\n                // Get the actual first document.\n                const { docs: [firstDoc] } = await db.find({\n                  ...options,\n                  limit: 1\n                });\n                if (firstDoc?._id !== doc._id) {\n                  docs[0] = firstDoc;\n                }\n              }\n              if (docs.length > limit) {\n                docs.splice(limit);\n              }\n              this.setStateIfMounted({\n                docs\n              });\n            }\n          }\n        );\n      }\n    }\n  }\n  render() {\n    const { props: { db, ...otherProps }, state: { docs } } = this;\n    return renderProps(otherProps, docs, { db, docs });\n  }\n}\n\nexport default withDB(Find);\n"],"file":"Find.js"}